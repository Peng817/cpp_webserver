# 线程同步机制类

为了使得线程池在响应请求时，能够将请求信息视作临界资源。因此，需要为线程准备线程同步机制类，来使得线程池的操作是同步性的。

创建`./thread_pool/locker.h`，`./thread_pool/locker.cpp`。

该类文件简单封装了3个类，分别是互斥锁类、条件变量类、信号量类。每个类只是将原有c语言中对应函数族的初始化、销毁和基本操作进行简单封装。

# 线程池类

创建 `./thread_pool/threadPool.h` , `./thread_pool/threadPool.cpp`

依照书上代码，构建了线程池类，从代码层次理解了所谓的半同步/半反应堆的线程池模式。

线程池类既维护了一个请求队列，也维护了一个线程池。请求队列通过互斥锁保证了对请求队列的访问是互斥的，通过信号量来控制线程池中的线程执行队列中的某一请求。线程池在线程池类的构造函数中就完成了线程池的构建和初始化，其每个线程都将执行线程池类中的worker函数，而worker函数最终将使得线程去获得请求队列中的某一请求，如此确保了线程池的每个线程去独立执行不同请求的执行函数。

请求队列中是否有任务需要线程来执行依赖上面提到的请求队列信号量，在构造函数中，其信号量被初始化为0，只有当线程池类调用append函数追加一个任务时，才会调用信号量的post函数增加一个值，这确保了信号量的值和请求队列中任务的数量是一致的。而对于所有的线程，其执行的worker函数在逻辑的开始就设立了一个信号量的wait函数，使得，对于一开始没有任务，即信号量为0的请求队列，所有的线程都将睡眠等待。而当append()添加一个任务后，才会有一个线程被唤醒，从而去执行该任务。

由于既使用到了互斥锁来保证线程池中线程访问请求队列，又使用了信号量来调控线程池中线程是否需要访问请求队列，所以这一块逻辑还是有点迷糊，总觉得使用了信号量，是否还额外使用互斥锁来限制进程是否有些多余，也因此产生了对于代码中一些使用互斥锁的部分感觉可以去掉的想法。
